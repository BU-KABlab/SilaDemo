# Generated by sila2.code_generator; sila2.__version__: 0.12.2
from __future__ import annotations

import asyncio
from datetime import timedelta
from typing import TYPE_CHECKING, Optional

import sartorius
from sila2.server import MetadataDict, ObservableCommandInstance

from ..generated.sartoriusscalecontroller import (
    Connect_Responses,
    MeasureWeight_Responses,
    SartoriusScaleControllerBase,
    Tare_Responses,
    Zero_Responses,
)

if TYPE_CHECKING:
    from ..server import Server


class SartoriusScaleControllerImpl(SartoriusScaleControllerBase):
    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)

        # Default lifetime of observable command instances. Possible values:
        # None: Command instance is valid and stored in memory until server shutdown
        # datetime.timedelta: Command instance is deleted after this duration, can be increased during command runtime
        self.MeasureWeight_default_lifetime_of_execution = timedelta(minutes=30)

        # Initialize scale connection as None
        self.scale = None
        self.connected = False
        self._unit = "g"
        self._stable = False
        self._scale_info = "Not connected"

        # Create an event loop for running async tasks from sync context
        self.loop = asyncio.get_event_loop()

    def get_ScaleInformation(self, *, metadata: MetadataDict) -> str:
        return self._scale_info

    def get_Unit(self, *, metadata: MetadataDict) -> str:
        return self._unit

    def get_ConnectionStatus(self, *, metadata: MetadataDict) -> bool:
        return self.connected

    def get_StableReading(self, *, metadata: MetadataDict) -> bool:
        return self._stable

    def Connect(
        self,
        Address: Optional[str] = "",
        IP: Optional[str] = "",
        Port: str = 49155,
        *,
        metadata: MetadataDict,
    ) -> Connect_Responses:
        try:
            # Close any existing connection
            if self.scale is not None:
                self.loop.run_until_complete(self._close_connection())

            # Create a new scale instance
            # Note: The Scale class doesn't have explicit connect method
            # Connection happens when we first communicate with it
            self.scale = sartorius.Scale(address=Address, ip=IP, port=Port)

            # Test the connection and get initial information
            async def initialize_connection():
                # Get initial scale information
                info = await self.scale.get_info()
                self._scale_info = (
                    f"Model: {info.get('model', 'Unknown')}, "
                    f"Serial: {info.get('serial', 'Unknown')}, "
                    f"Software: {info.get('software', 'Unknown')}"
                )

                # Get initial reading to test connection and get unit
                reading = await self.scale.get()
                self._unit = reading.get("units", "g")
                self._stable = reading.get("stable", False)

                self.connected = True
                return True

            success = self.loop.run_until_complete(initialize_connection())
            return Connect_Responses(Connected=success)

        except Exception as e:
            if self.scale is not None:
                self.loop.run_until_complete(self._close_connection())

            raise ConnectionError(
                f"Failed to connect to scale on port {Port}: {str(e)}"
            )

    async def _close_connection(self) -> None:
        """Close the connection to the scale.

        Note: Scale doesn't have an explicit disconnect method in the
        sartorius library. We're just releasing the reference.
        """
        if self.scale is not None:
            # No explicit disconnect method in Scale class
            # Just cleanup resources
            self.scale = None
            self.connected = False

    def Tare(self, *, metadata: MetadataDict) -> Tare_Responses:
        if not self.connected or self.scale is None:
            raise ConnectionError("Scale is not connected")

        try:
            # Run the async tare method
            async def tare_async():
                await self.scale.zero()  # Note: Using zero() as tare method

            self.loop.run_until_complete(tare_async())
            return Tare_Responses(Success=True)
        except Exception as e:
            raise ConnectionError(f"Failed to tare scale: {str(e)}")

    def Zero(self, *, metadata: MetadataDict) -> Zero_Responses:
        if not self.connected or self.scale is None:
            raise ConnectionError("Scale is not connected")

        try:
            # Run the async zero method
            async def zero_async():
                await self.scale.zero()

            self.loop.run_until_complete(zero_async())
            return Zero_Responses(Success=True)
        except Exception as e:
            raise ConnectionError(f"Failed to zero scale: {str(e)}")

    def MeasureWeight(
        self, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> MeasureWeight_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()

        if not self.connected or self.scale is None:
            instance.__status = "finishedWithError"
            raise ConnectionError("Scale is not connected")

        try:
            # Define the async function to get weight
            async def measure_weight_async():
                reading = await self.scale.get()
                self._stable = reading.get("stable", False)
                self._unit = reading.get("units", self._unit)
                return reading.get("mass", 0.0)

            # Get weight reading from scale by running the async function
            weight = self.loop.run_until_complete(measure_weight_async())

            # Create response with the weight
            response = MeasureWeight_Responses(Weight=weight)

            # Mark as completed and return response
            instance.__status = "finishedSuccessfully"
            return response

        except Exception as e:
            instance.error(str(e))
            raise

    def cleanup(self) -> None:
        """Close connection when server shuts down."""
        if self.scale is not None:
            self.loop.run_until_complete(self._close_connection())
